Interval/Segment Problems
- process by point

Sweep Line
- define line by rightmost included element on the left side

Order/Coordinate Compression
- order[1..N]
- order sort (a,b)->arr[a]-arr[b]

Query for ancestor-descendant relationship in a tree O(N+Q)
- using DFS store in time and pop time for each node
- ancestor_in < child_in && ancestor_out > child_out

LCA
* Binary Lifting
* Euler Tour

Online queries
- BIT
- Segment Tree
- Square Root Decomposition

Offline queries
- permute queries efficiently
- static preprocess
- Sparse Table

Geometry
- 3 points ccw:
    - based on Area(triangle): -1, 0, 1
- 2 lines intersection:
    for each line, the 2 other points are opposites in direction
- theta:
    dy/(dy+dx) is extremely different to an angle but has same ordering properties, returns a number [0,360]
- convex hull:
    package wrap O(NH)
    Graham Scan O(NlogN)
        find point with lowest y
        compute theta to all other points and sort by least
        add so that perimeter is always ccw

Fractions/Decimals
- epsilon
- rounding
- fraction class

Dynamic Programming
* Standard
    - base case, transition, states
* Range
    - calc dp[start][len] (messy)
        - for (len), for (start)
    - calc dp[l][r]
        - for (r=N,r--) for (l=r,l++)
* Sets
    - Usually N*2^N complexity
    - every subset is a state
    - transition example: 110111001 -> 111111001

Meet in the Middle
- splitting 2^N to N*2^(N/2)

Fast Powers O(logN)
pow(base,exp):
    if(exp==0): ret 1
    if(exp%2==1): ret base*pow(base,exp-1)
    if (exp%2==0): ret pow(base*base,exp/2)